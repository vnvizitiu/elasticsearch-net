@using System.Collections.Generic
@using System.Linq
@using CsQuery.ExtensionMethods.Internal
@using ApiGenerator.Domain
@using ApiGenerator
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using Elasticsearch.Net;

//This file lays the base for all the descriptors based on the query string parameters in the spec for IElasticClient.
//This file is automatically generated from https://github.com/elastic/elasticsearch/tree/master/rest-api-spec

namespace Nest
{
	public abstract partial class @Raw("RequestDescriptorBase<TDescriptor, TParameters, TInterface>")
	{
	@foreach (var common in RestApiSpec.CommonApiQueryParameters.Values)
	{
		var original = common.QueryStringKey;
		var t = @common.TypeHighLevel;
		var tSuffix = (t == "bool" || t == "bool?") ? " = true" : "";
		<text>		public TDescriptor @(common.ClsName)(@common.TypeHighLevel @common.ClsArgumentName@tSuffix) => Qs("@original", @(common.ClsArgumentName));</text>
	}
	}
	@foreach (CsharpMethod method in Model.CsharpMethodsWithQueryStringInfo)
	{
		var type = method.DescriptorType + method.DescriptorTypeGeneric;
	<text>
	///<summary>descriptor for @method.FullName <pre>@method.Documentation</pre></summary>
	public partial class @Raw(type) @(Raw(string.Format(" : RequestDescriptorBase<{0},{1}, {2}>, {2}", type, method.QueryStringParamName, method.InterfaceType)))
	{ 
@foreach (Constructor c in method.DescriptorConstructors())
{
<text>		@(Raw(CodeGenerator.Constructor(c)))
</text>
}
		// values part of the url path
@foreach (ApiUrlPart part in method.AllParts.Where(p=>!ApiUrl.BlackListRouteValues.Contains(p.Name)))
{
<text>		@(Raw(part.ClrTypeName)) @(Raw(method.InterfaceType)).@(part.InterfaceName) => Self.RouteValues.Get@(Raw(string.Format("<{0}>",part.ClrTypeName)))("@(part.Name)");</text>
}
@foreach (FluentRouteSetter c in method.GetFluentRouteSetters())
{
<text>		@(Raw(c.XmlDoc))
		@(Raw(c.Code))</text>
}
</text>
<text>		// Request parameters</text>
foreach (var param in method.Url.Params.Values)
{
	var original = param.QueryStringKey;
	//skip parameters already part of the path portion of the url
		if (method.Url.Parts != null && method.Url.Parts.ContainsKey(original))
		{
			continue;
		}
		//we prefer this parameter to be explictly implemented on the request body
		if (param.RenderPartial && (method.HttpMethod != "GET" && method.HttpMethod != "HEAD"))
		{
			continue;
		}
		var t = @param.TypeHighLevel;
		var tSuffix = (t == "bool" || t == "bool?") ? " = true" : "";
		var typed = !method.DescriptorTypeGeneric.IsNullOrEmpty();
		var g = typed ? method.DescriptorTypeGeneric.Replace("<", "").Replace(">", "") : "T";
		
		var desc = param.DescriptionHighLevel.ToList();
		<text>@if (desc.Count == 1) {
		<text>///<summary>@Raw(desc.First())</summary></text>
		}
		else 
		{ <text>		///<summary>
		@Raw(string.Join("\r\n\t\t", desc.Select(d=> "/// " + d)))
		///</summary></text>
		}</text><text>@if(!string.IsNullOrWhiteSpace(param.Obsolete))
		{<text>		[Obsolete("Scheduled to be removed in 7.0, @param.Obsolete")]
</text>}
		public @Raw(type) @(param.ClsName)(@param.DescriptorArgumentType @param.ClsArgumentName@tSuffix) => Qs("@original", @(param.ClsArgumentName));</text>
		if (param.IsFieldsParam)
		{
		<text>///<summary>@param.Description</summary>
		public @Raw(type) @param.ClsName@(Raw(typed ? "" : "<T>"))(params @Raw("Expression<Func<" + g + ", object>>[]") fields) @Raw(typed ? "" : "where "+ g + " : class") => Qs("@original", fields?@Raw(".Select(e=>(Field)e)"));</text>
		}
		else if (param.IsFieldParam)
		{<text>
		///<summary>@param.Description</summary>
		public @Raw(type) @param.ClsName@(Raw(typed ? "" : "<T>"))(@Raw("Expression<Func<"+ g +", object>>") field) @Raw(typed ? "" : "where " + g + " : class") => Qs("@original", (Field)field);</text>
		}
	}
	if (method.Unmapped)
	{<text>
		//TODO THIS METHOD IS UNMAPPED!
		</text>
	}	
	<text>
	}</text>
	}
}